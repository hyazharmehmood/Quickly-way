generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       String                    @id @default(uuid())
  name                     String
  email                    String                    @unique
  password                 String
  role                     UserRole                  @default(CLIENT)
  isSeller                 Boolean                   @default(false)
  sellerStatus             SellerStatus              @default(NONE)
  bio                      String?
  skills                   String[]
  portfolio                String?
  refreshToken             String?
  passwordResetToken       String?
  passwordResetExpires     DateTime?
  createdAt                DateTime                  @default(now())
  updatedAt                DateTime                  @updatedAt
  coverImage               String?
  languages                String[]
  profileImage             String?
  availability             Json?
  location                 String?
  phoneNumber              String?
  showEmail                Boolean                   @default(false)
  showMobile               Boolean                   @default(false)
  conversationParticipants ConversationParticipant[] @relation("ConversationParticipants")
  messages                 Message[]
  clientProjects           Project[]                 @relation("ClientProjects")
  freelancerProjects       Project[]                 @relation("FreelancerProjects")
  proposals                Proposal[]
  sellerApplication        SellerApplication?
  services                 Service[]
  clientContracts          Contract[]                @relation("ClientContracts")
  freelancerContracts      Contract[]                @relation("FreelancerContracts")
  contractEvents           ContractEvent[]
  disputes                 Dispute[]                 @relation("DisputeClient")
  disputesAsFreelancer     Dispute[]                 @relation("DisputeFreelancer")
  clientOrders             Order[]                    @relation("ClientOrders")
  freelancerOrders         Order[]                    @relation("FreelancerOrders")
  orderEvents              OrderEvent[]
  orderDisputesAsClient    OrderDispute[]             @relation("OrderDisputeClient")
  orderDisputesAsFreelancer OrderDispute[]             @relation("OrderDisputeFreelancer")
}

model Project {
  id           String        @id @default(uuid())
  title        String
  description  String
  budget       Float
  deadline     DateTime?
  status       ProjectStatus @default(OPEN)
  clientId     String
  freelancerId String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  client       User          @relation("ClientProjects", fields: [clientId], references: [id])
  freelancer   User?         @relation("FreelancerProjects", fields: [freelancerId], references: [id])
  proposals    Proposal[]
}

model Proposal {
  id           String         @id @default(uuid())
  bidAmount    Float
  coverLetter  String
  status       ProposalStatus @default(PENDING)
  projectId    String
  freelancerId String
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  freelancer   User           @relation(fields: [freelancerId], references: [id])
  project      Project        @relation(fields: [projectId], references: [id])
}

model SellerApplication {
  id              String       @id @default(uuid())
  fullName        String
  skills          String[]
  bio             String?
  portfolio       String?
  status          SellerStatus @default(PENDING)
  rejectionReason String?
  userId          String       @unique
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  user            User         @relation(fields: [userId], references: [id])
}

model Service {
  id              String   @id @default(uuid())
  title           String
  description     String
  category        String?
  subCategory     String?
  price           Float?
  currency        String   @default("USD")
  priceBreakdowns Json?
  images          String[]
  showEmail       Boolean  @default(false)
  showMobile      Boolean  @default(false)
  freelancerId    String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  coverColor      String?
  coverImage      String?
  coverText       String?
  coverType       String   @default("IMAGE")
  searchTags      String[]
  freelancer      User     @relation(fields: [freelancerId], references: [id])
  contracts       Contract[]
  orders          Order[]
}

model Conversation {
  id              String                    @id @default(uuid())
  createdAt       DateTime                  @default(now())
  updatedAt       DateTime                  @updatedAt
  lastMessageAt   DateTime?                 // Use this for conversation ordering (not updatedAt)
  lastMessageText String?
  lastSenderId    String?
  participants    ConversationParticipant[]
  messages        Message[]
  contracts       Contract[]
  orders          Order[]

  @@index([lastMessageAt])
  @@index([updatedAt])
}

model ConversationParticipant {
  id             String       @id @default(uuid())
  conversationId String
  userId         String
  joinedAt       DateTime     @default(now())
  lastReadAt     DateTime?
  unreadCount    Int          @default(0)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation("ConversationParticipants", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
}

model Message {
  id             String       @id @default(uuid())
  content        String
  senderId       String
  conversationId String
  type           String       @default("text") // "text", "image", "video", "file"
  attachmentUrl  String?      // URL for images, videos, or files
  attachmentName String?      // Original filename
  createdAt      DateTime     @default(now())
  deliveredAt    DateTime?    // When message was delivered to recipient's device
  seenAt         DateTime?    // When message was seen/read by recipient (from ConversationParticipant.lastReadAt)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User         @relation(fields: [senderId], references: [id])

  @@index([conversationId, createdAt])
  @@index([deliveredAt])
  @@index([seenAt])
}

enum UserRole {
  CLIENT
  FREELANCER
  ADMIN
}

enum SellerStatus {
  NONE
  PENDING
  APPROVED
  REJECTED
}

enum ProjectStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ProposalStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// Contract Model = Offer (Freelancer sends to Client)
// Contract acceptance does NOT mean work can start
// When contract is accepted, an Order is automatically created
model Contract {
  id                    String            @id @default(uuid())
  contractNumber        String?           @unique // Human-readable contract number (e.g., CTR-20240115-120530-ABCD)
  serviceId             String?
  clientId              String?
  freelancerId          String?
  conversationId        String?           // Link to conversation if exists
  serviceTitle          String
  serviceDescription    String
  scopeOfWork           String            // Detailed scope
  price                 Float
  currency              String            @default("USD")
  deliveryTime          Int               // Days for delivery
  revisionsIncluded     Int               @default(0)
  revisionsUsed         Int               @default(0)
  cancellationPolicy    String            // Terms for cancellation
  status                ContractStatus    @default(PENDING_ACCEPTANCE)
  clientAcceptedAt      DateTime?
  freelancerAcceptedAt  DateTime?
  clientIpAddress       String?           // IP when client created
  freelancerIpAddress   String?           // IP when freelancer accepted
  rejectionReason       String?
  rejectedAt            DateTime?
  rejectedBy            String?           // User ID
  completedAt           DateTime?
  deliveryDate          DateTime?         // Expected delivery date (from Order, not Contract)
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  // Relations
  service               Service?          @relation(fields: [serviceId], references: [id])
  client                User?             @relation("ClientContracts", fields: [clientId], references: [id])
  freelancer            User?              @relation("FreelancerContracts", fields: [freelancerId], references: [id])
  conversation          Conversation?     @relation(fields: [conversationId], references: [id])
  order                 Order?             // One-to-one: Contract â†’ Order (created when contract is accepted, Order has contractId foreign key)
  deliverables         ContractDeliverable[]
  events                ContractEvent[]
  disputes              Dispute[]

  @@index([clientId])
  @@index([freelancerId])
  @@index([serviceId])
  @@index([status])
  @@index([conversationId])
  @@index([contractNumber])
}

model ContractDeliverable {
  id                    String            @id @default(uuid())
  contractId            String
  type                  DeliverableType   @default(FILE)
  fileUrl               String?           // For FILE type
  message               String?           // Delivery message
  isRevision            Boolean           @default(false)
  revisionNumber        Int?              // Which revision (1, 2, 3...)
  deliveredAt           DateTime          @default(now())
  acceptedAt            DateTime?
  rejectedAt            DateTime?
  rejectionReason       String?
  
  contract              Contract          @relation(fields: [contractId], references: [id], onDelete: Cascade)

  @@index([contractId])
  @@index([deliveredAt])
}

model ContractEvent {
  id                    String            @id @default(uuid())
  contractId            String
  userId                String            // User who performed the action
  eventType             ContractEventType
  description           String?           // Human-readable description
  metadata              Json?             // Additional data (IP, reason, etc.)
  createdAt             DateTime          @default(now())
  
  contract              Contract          @relation(fields: [contractId], references: [id], onDelete: Cascade)
  user                  User              @relation(fields: [userId], references: [id])

  @@index([contractId])
  @@index([userId])
  @@index([eventType])
  @@index([createdAt])
}

// Order Model = Work Order (Created when Contract is accepted)
// Order becomes ACTIVE only when payment is processed (future implementation)
// Delivery countdown starts ONLY when order.status === ACTIVE
model Order {
  id                    String            @id @default(uuid())
  orderNumber           String            @unique // Human-readable order number (e.g., ORD-20240115-120530-ABCD)
  contractId             String            @unique // One-to-one with Contract
  serviceId              String?
  clientId               String
  freelancerId           String
  conversationId        String?           // Link to conversation
  
  // Order details (copied from contract at creation)
  serviceTitle           String
  serviceDescription     String
  scopeOfWork            String
  price                  Float
  currency               String            @default("USD")
  deliveryTime           Int               // Days for delivery
  revisionsIncluded      Int               @default(0)
  revisionsUsed          Int               @default(0)
  
  // Order status (workflow)
  status                 OrderStatus       @default(PENDING)
  
  // Payment status (for future payment integration)
  // When payment is implemented, order becomes ACTIVE only when paymentStatus === PAID
  paymentStatus          PaymentStatus     @default(PENDING)
  paymentMethod          String?           // "stripe", "paypal", "local", etc. (future)
  paymentTransactionId    String?           // Payment gateway transaction ID (future)
  paidAt                 DateTime?         // When payment was completed (future)
  
  // Delivery tracking
  deliveryDate           DateTime?         // Expected delivery date (calculated when order becomes ACTIVE)
  deliveredAt            DateTime?         // When work was delivered
  completedAt            DateTime?         // When order was completed
  
  // Cancellation
  cancelledAt            DateTime?
  cancellationReason     String?
  cancelledBy            String?           // User ID
  
  // Timestamps
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  
  // Relations
  contract               Contract          @relation(fields: [contractId], references: [id], onDelete: Cascade)
  service                 Service?          @relation(fields: [serviceId], references: [id])
  client                  User              @relation("ClientOrders", fields: [clientId], references: [id])
  freelancer              User              @relation("FreelancerOrders", fields: [freelancerId], references: [id])
  conversation            Conversation?     @relation(fields: [conversationId], references: [id])
  deliverables           OrderDeliverable[]
  events                 OrderEvent[]
  disputes               OrderDispute[]

  @@index([contractId])
  @@index([clientId])
  @@index([freelancerId])
  @@index([serviceId])
  @@index([status])
  @@index([paymentStatus])
  @@index([conversationId])
  @@index([orderNumber])
}

// Order Deliverables (work submissions)
model OrderDeliverable {
  id                    String            @id @default(uuid())
  orderId               String
  type                  DeliverableType   @default(FILE)
  fileUrl               String?           // For FILE type
  message               String?           // Delivery message
  isRevision            Boolean           @default(false)
  revisionNumber        Int?              // Which revision (1, 2, 3...)
  deliveredAt           DateTime          @default(now())
  acceptedAt            DateTime?
  rejectedAt            DateTime?
  rejectionReason       String?
  
  order                 Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([deliveredAt])
}

// Order Events (audit trail)
model OrderEvent {
  id                    String            @id @default(uuid())
  orderId               String
  userId                String            // User who performed the action
  eventType             OrderEventType
  description           String?           // Human-readable description
  metadata              Json?             // Additional data (IP, reason, etc.)
  createdAt             DateTime          @default(now())
  
  order                 Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  user                  User              @relation(fields: [userId], references: [id])

  @@index([orderId])
  @@index([userId])
  @@index([eventType])
  @@index([createdAt])
}

// Order Disputes
model OrderDispute {
  id                    String            @id @default(uuid())
  orderId               String
  clientId              String
  freelancerId          String
  reason                String
  description           String
  status                DisputeStatus     @default(OPEN)
  adminResolution       String?           // Admin's resolution text
  resolvedBy            String?           // Admin user ID
  resolvedAt            DateTime?
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  order                 Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  client                User              @relation("OrderDisputeClient", fields: [clientId], references: [id])
  freelancer            User              @relation("OrderDisputeFreelancer", fields: [freelancerId], references: [id])

  @@index([orderId])
  @@index([status])
  @@index([clientId])
  @@index([freelancerId])
}

model Dispute {
  id                    String            @id @default(uuid())
  contractId            String
  clientId              String
  freelancerId          String
  reason                String
  description           String
  status                DisputeStatus     @default(OPEN)
  adminResolution       String?           // Admin's resolution text
  resolvedBy            String?           // Admin user ID
  resolvedAt            DateTime?
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  contract              Contract          @relation(fields: [contractId], references: [id], onDelete: Cascade)
  client                User              @relation("DisputeClient", fields: [clientId], references: [id])
  freelancer            User              @relation("DisputeFreelancer", fields: [freelancerId], references: [id])

  @@index([contractId])
  @@index([status])
  @@index([clientId])
  @@index([freelancerId])
}

enum ContractStatus {
  PENDING_ACCEPTANCE
  ACTIVE
  DELIVERED
  REVISION_REQUESTED
  COMPLETED
  REJECTED
  CANCELLED
  DISPUTED
}

enum DeliverableType {
  FILE
  MESSAGE
  LINK
}

enum ContractEventType {
  CONTRACT_CREATED
  CONTRACT_ACCEPTED
  CONTRACT_REJECTED
  CONTRACT_ACTIVE
}

enum DisputeStatus {
  OPEN
  IN_REVIEW
  RESOLVED
  CLOSED
}

// Order Status - Workflow status (independent of payment)
enum OrderStatus {
  PENDING                 // Order created, waiting for payment (default)
  ACTIVE                  // Payment completed, work can start (delivery countdown starts)
  DELIVERED               // Freelancer submitted work
  REVISION_REQUESTED      // Client requested revision
  COMPLETED               // Client accepted delivery
  CANCELLED               // Order cancelled
  DISPUTED                // Order in dispute
}

// Payment Status - Payment processing status
// FUTURE: When payment is integrated, order becomes ACTIVE only when paymentStatus === PAID
enum PaymentStatus {
  PENDING                 // Payment not yet processed (default)
  PAID                    // Payment completed successfully (future)
  REFUNDED                // Payment refunded (future)
  FAILED                  // Payment failed (future)
}

// Order Event Types
enum OrderEventType {
  ORDER_CREATED           // Order created when contract accepted
  ORDER_ACTIVATED         // Order became ACTIVE (payment completed - future)
  DELIVERY_SUBMITTED      // Freelancer submitted work
  DELIVERY_ACCEPTED       // Client accepted delivery
  REVISION_REQUESTED      // Client requested revision
  ORDER_COMPLETED          // Order completed
  ORDER_CANCELLED         // Order cancelled
  DISPUTE_OPENED          // Dispute opened
  DISPUTE_RESOLVED        // Dispute resolved
  STATUS_CHANGED          // Status changed
}
