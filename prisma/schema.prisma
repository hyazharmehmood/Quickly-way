generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       String                    @id @default(uuid())
  name                     String
  email                    String                    @unique
  password                 String
  role                     UserRole                  @default(CLIENT)
  isSeller                 Boolean                   @default(false)
  sellerStatus             SellerStatus              @default(NONE)
  bio                      String?
  portfolio                String?
  refreshToken             String?
  passwordResetToken       String?
  passwordResetExpires     DateTime?
  createdAt                DateTime                  @default(now())
  updatedAt                DateTime                  @updatedAt
  coverImage               String?
  languages                String[]
  profileImage             String?
  availability             Json?
  location                 String?
  phoneNumber              String?
  showEmail                Boolean                   @default(false)
  showMobile               Boolean                   @default(false)
  yearsOfExperience        Int?                      // Years of experience as seller
  employmentStatus         String?                   // e.g. "I am ready for full-time employment" when checkbox checked
  conversationParticipants ConversationParticipant[] @relation("ConversationParticipants")
  messages                 Message[]
  clientProjects           Project[]                 @relation("ClientProjects")
  freelancerProjects       Project[]                 @relation("FreelancerProjects")
  proposals                Proposal[]
  sellerApplication        SellerApplication?
  services                 Service[]
  clientOrders             Order[]                   @relation("ClientOrders")
  freelancerOrders         Order[]                   @relation("FreelancerOrders")
  clientOffers             Offer[]                   @relation("ClientOffers")
  freelancerOffers         Offer[]                   @relation("FreelancerOffers")
  orderEvents              OrderEvent[]
  disputes                 Dispute[]                 @relation("DisputeClient")
  disputesAsFreelancer     Dispute[]                 @relation("DisputeFreelancer")
  reviewsGiven              Review[]                  @relation("Reviewer")
  reviewsReceived           Review[]                 @relation("Reviewee")
  reviewsApproved           Review[]                 @relation("ReviewApprovedBy")
  reviewsFlagged            Review[]                 @relation("ReviewFlaggedBy")
  disputeComments           DisputeComment[]         @relation("DisputeCommentAuthor")
  notifications             Notification[]
  rating                    Float?                   @default(0) // Average rating from reviews
  reviewCount               Int                       @default(0) // Total number of reviews received
  requestedSkills           Skill[]                  @relation("RequestedSkills") // Skills requested by this user (pending/rejected)
  requestedKeywords         Keyword[]                @relation("RequestedKeywords") // Keywords requested by this user (pending/rejected)
  supportTicketsCreated     SupportTicket[]          @relation("SupportTicketCreator")
  supportTicketsAssigned    SupportTicket[]          @relation("SupportTicketAgent")
  supportTicketMessages     SupportTicketMessage[]   @relation("SupportTicketMessageAuthor")
  roleAgreementRequests     RoleAgreementRequest[]
  roleAgreementReviews     RoleAgreementRequest[]    @relation("RoleAgreementReviewedBy")
}

// Contact support tickets (separate from order disputes)
enum SupportTicketStatus {
  OPEN             // Service request opened
  AGENT_ASSIGNED   // Agent assigned, in progress
  RESOLVED         // Issue resolved
}

model SupportTicket {
  id              String                   @id @default(uuid())
  ticketNo        String                   @unique // Human-readable e.g. 261250003612
  title           String
  description     String
  fullName        String
  email           String
  createdById     String?                  // If user was logged in
  assignedAgentId String?                  // Admin/agent user assigned
  status          SupportTicketStatus      @default(OPEN)
  createdAt       DateTime                 @default(now())
  updatedAt       DateTime                 @updatedAt
  createdBy       User?                    @relation("SupportTicketCreator", fields: [createdById], references: [id], onDelete: SetNull)
  assignedAgent   User?                    @relation("SupportTicketAgent", fields: [assignedAgentId], references: [id], onDelete: SetNull)
  attachments     SupportTicketAttachment[]
  messages        SupportTicketMessage[]

  @@index([email])
  @@index([createdById])
  @@index([assignedAgentId])
  @@index([status])
  @@index([createdAt])
}

model SupportTicketAttachment {
  id        String        @id @default(uuid())
  ticketId  String
  fileUrl   String
  fileName  String
  createdAt DateTime      @default(now())
  ticket    SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId])
}

enum SupportTicketMessageRole {
  CLIENT
  AGENT
  ADMIN
}

model SupportTicketMessage {
  id        String                    @id @default(uuid())
  ticketId  String
  senderId  String
  role      SupportTicketMessageRole
  content   String
  attachments Json?                   // Array of { url, name, type }
  createdAt DateTime                  @default(now())
  ticket    SupportTicket             @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  sender    User                      @relation("SupportTicketMessageAuthor", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([ticketId, createdAt])
  @@index([senderId])
}

model Project {
  id           String        @id @default(uuid())
  title        String
  description  String
  budget       Float
  deadline     DateTime?
  status       ProjectStatus @default(OPEN)
  clientId     String
  freelancerId String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  client       User          @relation("ClientProjects", fields: [clientId], references: [id])
  freelancer   User?         @relation("FreelancerProjects", fields: [freelancerId], references: [id])
  proposals    Proposal[]
}

model Proposal {
  id           String         @id @default(uuid())
  bidAmount    Float
  coverLetter  String
  status       ProposalStatus @default(PENDING)
  projectId    String
  freelancerId String
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  freelancer   User           @relation(fields: [freelancerId], references: [id])
  project      Project        @relation(fields: [projectId], references: [id])
}

model SellerApplication {
  id              String       @id @default(uuid())
  fullName        String
  skills          String[]
  bio             String?
  portfolio       String?
  status          SellerStatus @default(PENDING)
  rejectionReason String?
  userId          String       @unique
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  user            User         @relation(fields: [userId], references: [id])
}

// Join as Client / Join as Freelancer: user agrees to terms, request goes to admin, admin approves
model RoleAgreementRequest {
  id              String              @id @default(uuid())
  userId          String
  requestedRole   RequestedRole       // CLIENT or FREELANCER
  status          SellerStatus        @default(PENDING) // PENDING, APPROVED, REJECTED
  agreedAt        DateTime            @default(now())
  rejectionReason String?
  reviewedAt      DateTime?
  reviewedById    String?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewedBy      User?               @relation("RoleAgreementReviewedBy", fields: [reviewedById], references: [id], onDelete: SetNull)

  @@unique([userId, requestedRole])
  @@index([status])
  @@index([requestedRole])
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  type      String   @default("general")
  title     String
  body      String?
  priority  String   @default("normal")
  data      Json?
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([createdAt])
}

model Service {
  id              String        @id @default(uuid())
  title           String
  description     String
  category        String?
  subCategory     String?
  price           Float?
  currency        String        @default("USD")
  priceBreakdowns Json?
  images          String[]
  showEmail       Boolean       @default(false)
  showMobile      Boolean       @default(false)
  freelancerId    String
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  coverColor      String?
  coverImage      String?
  coverText       String?
  coverType       String        @default("IMAGE")
  searchTags      String[]
  paymentRegion   String?       // e.g. "SAUDI_ARABIA", "GLOBAL" - default SAUDI_ARABIA (backend only)
  paymentMethods  String[]      // Selected method labels, e.g. ["Mada (HyperPay)", "Moyasar"]
  paymentMethodsText   String?  // Custom text e.g. "I accept payments via quicklyway"
  paymentMethodsTextAr String?  // Arabic version of payment methods text
  freelancer      User          @relation(fields: [freelancerId], references: [id])
  skills          ServiceSkill[]
  orders          Order[]
  offers          Offer[]
  reviews         Review[]      @relation("ServiceReviews")
}

model Conversation {
  id              String                    @id @default(uuid())
  createdAt       DateTime                  @default(now())
  updatedAt       DateTime                  @updatedAt
  lastMessageAt   DateTime?                 // Use this for conversation ordering (not updatedAt)
  lastMessageText String?
  lastSenderId    String?
  participants    ConversationParticipant[]
  messages        Message[]
  orders          Order[]
  offers          Offer[]

  @@index([lastMessageAt])
  @@index([updatedAt])
}

model ConversationParticipant {
  id             String       @id @default(uuid())
  conversationId String
  userId         String
  joinedAt       DateTime     @default(now())
  lastReadAt     DateTime?
  unreadCount    Int          @default(0)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation("ConversationParticipants", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
}

model Message {
  id             String       @id @default(uuid())
  content        String
  senderId       String
  conversationId String
  type           String       @default("text") // "text", "image", "video", "file", "offer"
  attachmentUrl  String?      // URL for images, videos, or files
  attachmentName String?      // Original filename (for file attachments)
  offerId        String?      // Direct relation to offer (for offer messages)
  orderId        String?      // Direct relation to order (set when offer accepted)
  createdAt      DateTime     @default(now())
  deliveredAt    DateTime?    // When message was delivered to recipient's device
  seenAt         DateTime?    // When message was seen/read by recipient (from ConversationParticipant.lastReadAt)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User         @relation(fields: [senderId], references: [id])
  offer          Offer?       @relation(fields: [offerId], references: [id], onDelete: SetNull)
  order          Order?       @relation(fields: [orderId], references: [id], onDelete: SetNull)

  @@index([conversationId, createdAt])
  @@index([deliveredAt])
  @@index([seenAt])
  @@index([offerId])
  @@index([orderId])
}

// Category and Skill Models (Admin-managed)
// Hierarchical Category structure: Main Category → Subcategories → Skills
model Category {
  id          String     @id @default(uuid())
  name        String
  slug        String     @unique
  isActive    Boolean    @default(true)
  parentId    String?    // null for main categories, set for subcategories
  parent      Category?   @relation("CategoryTree", fields: [parentId], references: [id], onDelete: Cascade)
  children    Category[]  @relation("CategoryTree")
  skills      Skill[]
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@unique([parentId, name]) // Category name unique within same parent (or root if parentId is null)
  @@index([slug])
  @@index([isActive])
  @@index([parentId])
  @@index([name])
}

model Skill {
  id               String              @id @default(uuid())
  categoryId       String
  name             String
  slug             String
  isActive         Boolean             @default(true)
  approvalStatus   SkillApprovalStatus @default(APPROVED) // PENDING = only creator sees; APPROVED = global; REJECTED = only creator sees
  createdByUserId  String?             // Who requested (for PENDING/REJECTED); null = admin-created or legacy
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  category         Category            @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  createdBy        User?               @relation("RequestedSkills", fields: [createdByUserId], references: [id], onDelete: SetNull)
  services         ServiceSkill[]

  @@unique([categoryId, name]) // Skill name unique within category
  @@unique([categoryId, slug]) // Slug unique within category
  @@index([categoryId])
  @@index([slug])
  @@index([isActive])
  @@index([approvalStatus])
  @@index([createdByUserId])
}

model ServiceSkill {
  id        String   @id @default(uuid())
  serviceId String
  skillId   String
  createdAt DateTime @default(now())
  service   Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  skill     Skill    @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@unique([serviceId, skillId]) // One skill can only be added once per service
  @@index([serviceId])
  @@index([skillId])
}

enum KeywordApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

model Keyword {
  id               String                @id @default(uuid())
  keyword          String                @unique
  volume           String?               // e.g., "12k", "4.5k"
  difficulty       String?               // "Low", "Medium", "High"
  rank             Int?                  // Current search rank
  trend            String?               // "up", "down", "stable"
  isActive         Boolean               @default(true)
  approvalStatus   KeywordApprovalStatus @default(APPROVED)
  createdByUserId  String?               // Who requested (for PENDING/REJECTED)
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  createdBy        User?                 @relation("RequestedKeywords", fields: [createdByUserId], references: [id], onDelete: SetNull)

  @@index([keyword])
  @@index([isActive])
  @@index([approvalStatus])
  @@index([createdByUserId])
}

// Trending search keywords - count incremented on each search
model SearchKeyword {
  id        String   @id @default(uuid())
  keyword   String   @unique
  count     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([keyword])
  @@index([count])
}

enum UserRole {
  CLIENT
  FREELANCER
  ADMIN
}

enum RequestedRole {
  CLIENT
  FREELANCER
}

enum SellerStatus {
  NONE
  PENDING
  APPROVED
  REJECTED
}

enum SkillApprovalStatus {
  PENDING   // Freelancer requested; only creator sees it until admin approves/rejects
  APPROVED  // Admin approved; visible to all freelancers in dropdown
  REJECTED  // Admin rejected; only creator sees it, labeled "Rejected"
}

enum ProjectStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ProposalStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// Offer Model (Fiverr-like: Freelancer sends offer, Client accepts/rejects, then Order is created)
model Offer {
  id                    String            @id @default(uuid())
  serviceId             String
  clientId              String
  freelancerId          String
  conversationId        String?           // Link to conversation
  status                OfferStatus       @default(PENDING)
  price                 Float
  currency              String            @default("USD")
  deliveryTime          Int               // Days for delivery
  revisionsIncluded     Int               @default(0)
  scopeOfWork           String            // Detailed scope
  cancellationPolicy    String?           // Terms for cancellation
  serviceTitle          String            // Service title at time of offer
  serviceDescription    String?          // Service description at time of offer
  rejectionReason       String?
  rejectedAt            DateTime?
  acceptedAt            DateTime?
  orderId               String?           @unique // If accepted, link to created order (one-to-one)
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  // Relations
  service               Service           @relation(fields: [serviceId], references: [id])
  client                User              @relation("ClientOffers", fields: [clientId], references: [id])
  freelancer            User              @relation("FreelancerOffers", fields: [freelancerId], references: [id])
  conversation          Conversation?     @relation(fields: [conversationId], references: [id])
  order                 Order?            @relation(fields: [orderId], references: [id])
  messages              Message[]

  @@index([clientId])
  @@index([freelancerId])
  @@index([serviceId])
  @@index([status])
  @@index([conversationId])
  @@index([orderId])
}

// Order Models
model Order {
  id                    String            @id @default(uuid())
  orderNumber           String            @unique // Human-readable order number (e.g., ORD-2024-001)
  serviceId             String
  clientId              String
  freelancerId          String
  conversationId        String?           // Link to conversation if exists
  offerId               String?           // If order created from offer
  status                OrderStatus       @default(PENDING_ACCEPTANCE)
  price                 Float
  currency              String            @default("USD")
  deliveryTime          Int               // Days for delivery
  revisionsIncluded     Int               @default(0)
  revisionsUsed         Int               @default(0)
  deliveryDate          DateTime?         // Expected delivery date
  completedAt           DateTime?
  cancelledAt           DateTime?
  cancellationReason    String?
  cancelledBy           String?           // User ID who cancelled
  clientIpAddress       String?           // IP address when order created
  paymentMethodUsed     String?           // Payment method selected by client (e.g. "Mada (HyperPay)")
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  // Relations
  service               Service           @relation(fields: [serviceId], references: [id])
  client                User              @relation("ClientOrders", fields: [clientId], references: [id])
  freelancer            User              @relation("FreelancerOrders", fields: [freelancerId], references: [id])
  conversation          Conversation?     @relation(fields: [conversationId], references: [id])
  offer                 Offer?            @relation // Reverse relation - Offer owns the relation via orderId
  messages              Message[]
  deliverables          OrderDeliverable[]
  events                OrderEvent[]
  disputes              Dispute[]
  reviews               Review[]

  @@index([clientId])
  @@index([freelancerId])
  @@index([serviceId])
  @@index([status])
  @@index([conversationId])
  @@index([orderNumber])
}

model OrderDeliverable {
  id                    String            @id @default(uuid())
  orderId               String
  type                  DeliverableType   @default(FILE)
  fileUrl               String?           // For FILE type
  message               String?           // Delivery message
  isRevision            Boolean           @default(false)
  revisionNumber        Int?              // Which revision (1, 2, 3...)
  deliveredAt           DateTime          @default(now())
  acceptedAt            DateTime?
  rejectedAt            DateTime?
  rejectionReason       String?
  
  order                 Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([deliveredAt])
}

model OrderEvent {
  id                    String            @id @default(uuid())
  orderId               String
  userId                String            // User who performed the action
  eventType             OrderEventType
  description           String?           // Human-readable description
  metadata              Json?             // Additional data (IP, reason, etc.)
  createdAt             DateTime          @default(now())
  
  order                 Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  user                  User              @relation(fields: [userId], references: [id])

  @@index([orderId])
  @@index([userId])
  @@index([eventType])
  @@index([createdAt])
}

model Dispute {
  id                    String            @id @default(uuid())
  orderId               String
  clientId              String
  freelancerId          String
  reason                String
  description           String
  status                DisputeStatus     @default(OPEN)
  adminResolution       String?           // Admin's resolution text
  resolvedBy            String?           // Admin user ID
  resolvedAt            DateTime?
  initialAttachments     Json?             // Array of attachment URLs from initial dispute
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  order                 Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  client                User              @relation("DisputeClient", fields: [clientId], references: [id])
  freelancer            User              @relation("DisputeFreelancer", fields: [freelancerId], references: [id])
  comments              DisputeComment[]

  @@index([orderId])
  @@index([status])
  @@index([clientId])
  @@index([freelancerId])
}

model DisputeComment {
  id                    String            @id @default(uuid())
  disputeId              String
  userId                String            // User who wrote the comment
  role                  DisputeCommentRole // CLIENT, FREELANCER, ADMIN
  content               String            // Comment text
  attachments           Json?             // Array of {url, name, type} objects
  createdAt             DateTime          @default(now())
  
  dispute               Dispute           @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  user                  User              @relation("DisputeCommentAuthor", fields: [userId], references: [id])

  @@index([disputeId, createdAt])
  @@index([userId])
}

enum DisputeCommentRole {
  CLIENT
  FREELANCER
  ADMIN
}

enum OrderStatus {
  PENDING_ACCEPTANCE
  IN_PROGRESS
  DELIVERED
  REVISION_REQUESTED
  COMPLETED
  CANCELLED
  DISPUTED
}

enum DeliverableType {
  FILE
  MESSAGE
  LINK
}

enum OrderEventType {
  ORDER_CREATED
  ORDER_IN_PROGRESS
  DELIVERY_SUBMITTED
  DELIVERY_ACCEPTED
  REVISION_REQUESTED
  ORDER_COMPLETED
  ORDER_CANCELLED
  DISPUTE_OPENED
  DISPUTE_RESOLVED
  STATUS_CHANGED
}

enum DisputeStatus {
  OPEN
  IN_REVIEW
  RESOLVED
  CLOSED
}

enum OfferStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

// Review Model - Supports both order-based and service-based reviews
model Review {
  id                    String            @id @default(uuid())
  orderId               String?           // Link to order (for order-based reviews)
  serviceId             String?            // Link to service (for service/gig-based reviews)
  reviewerId            String             // User who wrote the review
  revieweeId            String             // User being reviewed (freelancer or client)
  rating                Int                // 1-5 stars
  comment               String?            // Review text
  isOrderReview         Boolean            @default(true) // true = order-based, false = service-based
  isClientReview        Boolean            // true = client reviewing freelancer, false = freelancer reviewing client
  isApproved             Boolean            @default(true) // Admin approval status
  isFlagged              Boolean            @default(false) // Whether review is flagged for review
  isFeatured             Boolean            @default(false) // Whether review is featured
  flaggedReason          String?            // Reason for flagging
  flaggedBy              String?            // Admin user ID who flagged
  flaggedAt              DateTime?          // When review was flagged
  approvedBy             String?            // Admin user ID who approved
  approvedAt             DateTime?          // When review was approved
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  
  // Relations
  order                 Order?             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  service               Service?           @relation("ServiceReviews", fields: [serviceId], references: [id], onDelete: Cascade)
  reviewer              User               @relation("Reviewer", fields: [reviewerId], references: [id])
  reviewee              User               @relation("Reviewee", fields: [revieweeId], references: [id])
  approvedByUser        User?              @relation("ReviewApprovedBy", fields: [approvedBy], references: [id])
  flaggedByUser         User?              @relation("ReviewFlaggedBy", fields: [flaggedBy], references: [id])

  @@unique([orderId, reviewerId, isClientReview]) // One review per order per reviewer type
  @@index([orderId])
  @@index([serviceId])
  @@index([reviewerId])
  @@index([revieweeId])
  @@index([isOrderReview])
  @@index([createdAt])
}
