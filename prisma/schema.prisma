generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       String                    @id @default(uuid())
  name                     String
  email                    String                    @unique
  password                 String
  role                     UserRole                  @default(CLIENT)
  isSeller                 Boolean                   @default(false)
  sellerStatus             SellerStatus              @default(NONE)
  bio                      String?
  skills                   String[]
  portfolio                String?
  refreshToken             String?
  passwordResetToken       String?
  passwordResetExpires     DateTime?
  createdAt                DateTime                  @default(now())
  updatedAt                DateTime                  @updatedAt
  coverImage               String?
  languages                String[]
  profileImage             String?
  availability             Json?
  location                 String?
  phoneNumber              String?
  showEmail                Boolean                   @default(false)
  showMobile               Boolean                   @default(false)
  conversationParticipants ConversationParticipant[] @relation("ConversationParticipants")
  messages                 Message[]
  clientProjects           Project[]                 @relation("ClientProjects")
  freelancerProjects       Project[]                 @relation("FreelancerProjects")
  proposals                Proposal[]
  sellerApplication        SellerApplication?
  services                 Service[]
  clientOrders             Order[]                   @relation("ClientOrders")
  freelancerOrders         Order[]                   @relation("FreelancerOrders")
  clientOffers             Offer[]                   @relation("ClientOffers")
  freelancerOffers         Offer[]                   @relation("FreelancerOffers")
  orderEvents              OrderEvent[]
  disputes                 Dispute[]                 @relation("DisputeClient")
  disputesAsFreelancer     Dispute[]                 @relation("DisputeFreelancer")
}

model Project {
  id           String        @id @default(uuid())
  title        String
  description  String
  budget       Float
  deadline     DateTime?
  status       ProjectStatus @default(OPEN)
  clientId     String
  freelancerId String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  client       User          @relation("ClientProjects", fields: [clientId], references: [id])
  freelancer   User?         @relation("FreelancerProjects", fields: [freelancerId], references: [id])
  proposals    Proposal[]
}

model Proposal {
  id           String         @id @default(uuid())
  bidAmount    Float
  coverLetter  String
  status       ProposalStatus @default(PENDING)
  projectId    String
  freelancerId String
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  freelancer   User           @relation(fields: [freelancerId], references: [id])
  project      Project        @relation(fields: [projectId], references: [id])
}

model SellerApplication {
  id              String       @id @default(uuid())
  fullName        String
  skills          String[]
  bio             String?
  portfolio       String?
  status          SellerStatus @default(PENDING)
  rejectionReason String?
  userId          String       @unique
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  user            User         @relation(fields: [userId], references: [id])
}

model Service {
  id              String   @id @default(uuid())
  title           String
  description     String
  category        String?
  subCategory     String?
  price           Float?
  currency        String   @default("USD")
  priceBreakdowns Json?
  images          String[]
  showEmail       Boolean  @default(false)
  showMobile      Boolean  @default(false)
  freelancerId    String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  coverColor      String?
  coverImage      String?
  coverText       String?
  coverType       String   @default("IMAGE")
  searchTags      String[]
  freelancer      User     @relation(fields: [freelancerId], references: [id])
  orders          Order[]
  offers          Offer[]
}

model Conversation {
  id              String                    @id @default(uuid())
  createdAt       DateTime                  @default(now())
  updatedAt       DateTime                  @updatedAt
  lastMessageAt   DateTime?                 // Use this for conversation ordering (not updatedAt)
  lastMessageText String?
  lastSenderId    String?
  participants    ConversationParticipant[]
  messages        Message[]
  orders          Order[]
  offers          Offer[]

  @@index([lastMessageAt])
  @@index([updatedAt])
}

model ConversationParticipant {
  id             String       @id @default(uuid())
  conversationId String
  userId         String
  joinedAt       DateTime     @default(now())
  lastReadAt     DateTime?
  unreadCount    Int          @default(0)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation("ConversationParticipants", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
}

model Message {
  id             String       @id @default(uuid())
  content        String
  senderId       String
  conversationId String
  type           String       @default("text") // "text", "image", "video", "file"
  attachmentUrl  String?      // URL for images, videos, or files
  attachmentName String?      // Original filename
  createdAt      DateTime     @default(now())
  deliveredAt    DateTime?    // When message was delivered to recipient's device
  seenAt         DateTime?    // When message was seen/read by recipient (from ConversationParticipant.lastReadAt)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User         @relation(fields: [senderId], references: [id])

  @@index([conversationId, createdAt])
  @@index([deliveredAt])
  @@index([seenAt])
}

// Category and Skill Models (Admin-managed)
// Hierarchical Category structure: Main Category → Subcategories → Skills
model Category {
  id          String     @id @default(uuid())
  name        String
  slug        String     @unique
  isActive    Boolean    @default(true)
  parentId    String?    // null for main categories, set for subcategories
  parent      Category?   @relation("CategoryTree", fields: [parentId], references: [id], onDelete: Cascade)
  children    Category[]  @relation("CategoryTree")
  skills      Skill[]
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@unique([parentId, name]) // Category name unique within same parent (or root if parentId is null)
  @@index([slug])
  @@index([isActive])
  @@index([parentId])
  @@index([name])
}

model Skill {
  id          String   @id @default(uuid())
  categoryId  String
  name        String
  slug        String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  category    Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([categoryId, name]) // Skill name unique within category
  @@unique([categoryId, slug]) // Slug unique within category
  @@index([categoryId])
  @@index([slug])
  @@index([isActive])
}

enum UserRole {
  CLIENT
  FREELANCER
  ADMIN
}

enum SellerStatus {
  NONE
  PENDING
  APPROVED
  REJECTED
}

enum ProjectStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ProposalStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// Offer Model (Fiverr-like: Freelancer sends offer, Client accepts/rejects, then Order is created)
model Offer {
  id                    String            @id @default(uuid())
  serviceId             String
  clientId              String
  freelancerId          String
  conversationId        String?           // Link to conversation
  status                OfferStatus       @default(PENDING)
  price                 Float
  currency              String            @default("USD")
  deliveryTime          Int               // Days for delivery
  revisionsIncluded     Int               @default(0)
  scopeOfWork           String            // Detailed scope
  cancellationPolicy    String?           // Terms for cancellation
  serviceTitle          String            // Service title at time of offer
  serviceDescription    String?          // Service description at time of offer
  rejectionReason       String?
  rejectedAt            DateTime?
  acceptedAt            DateTime?
  orderId               String?           @unique // If accepted, link to created order (one-to-one)
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  // Relations
  service               Service           @relation(fields: [serviceId], references: [id])
  client                User              @relation("ClientOffers", fields: [clientId], references: [id])
  freelancer            User              @relation("FreelancerOffers", fields: [freelancerId], references: [id])
  conversation          Conversation?     @relation(fields: [conversationId], references: [id])
  order                 Order?            @relation(fields: [orderId], references: [id])

  @@index([clientId])
  @@index([freelancerId])
  @@index([serviceId])
  @@index([status])
  @@index([conversationId])
  @@index([orderId])
}

// Order Models
model Order {
  id                    String            @id @default(uuid())
  orderNumber           String            @unique // Human-readable order number (e.g., ORD-2024-001)
  serviceId             String
  clientId              String
  freelancerId          String
  conversationId        String?           // Link to conversation if exists
  offerId               String?           // If order created from offer
  status                OrderStatus       @default(PENDING_ACCEPTANCE)
  price                 Float
  currency              String            @default("USD")
  deliveryTime          Int               // Days for delivery
  revisionsIncluded     Int               @default(0)
  revisionsUsed         Int               @default(0)
  deliveryDate          DateTime?         // Expected delivery date
  completedAt           DateTime?
  cancelledAt           DateTime?
  cancellationReason    String?
  cancelledBy           String?           // User ID who cancelled
  clientIpAddress       String?           // IP address when order created
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  // Relations
  service               Service           @relation(fields: [serviceId], references: [id])
  client                User              @relation("ClientOrders", fields: [clientId], references: [id])
  freelancer            User              @relation("FreelancerOrders", fields: [freelancerId], references: [id])
  conversation          Conversation?     @relation(fields: [conversationId], references: [id])
  offer                 Offer?            @relation // Reverse relation - Offer owns the relation via orderId
  deliverables          OrderDeliverable[]
  events                OrderEvent[]
  disputes              Dispute[]

  @@index([clientId])
  @@index([freelancerId])
  @@index([serviceId])
  @@index([status])
  @@index([conversationId])
  @@index([orderNumber])
}

model OrderDeliverable {
  id                    String            @id @default(uuid())
  orderId               String
  type                  DeliverableType   @default(FILE)
  fileUrl               String?           // For FILE type
  message               String?           // Delivery message
  isRevision            Boolean           @default(false)
  revisionNumber        Int?              // Which revision (1, 2, 3...)
  deliveredAt           DateTime          @default(now())
  acceptedAt            DateTime?
  rejectedAt            DateTime?
  rejectionReason       String?
  
  order                 Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([deliveredAt])
}

model OrderEvent {
  id                    String            @id @default(uuid())
  orderId               String
  userId                String            // User who performed the action
  eventType             OrderEventType
  description           String?           // Human-readable description
  metadata              Json?             // Additional data (IP, reason, etc.)
  createdAt             DateTime          @default(now())
  
  order                 Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  user                  User              @relation(fields: [userId], references: [id])

  @@index([orderId])
  @@index([userId])
  @@index([eventType])
  @@index([createdAt])
}

model Dispute {
  id                    String            @id @default(uuid())
  orderId               String
  clientId              String
  freelancerId          String
  reason                String
  description           String
  status                DisputeStatus     @default(OPEN)
  adminResolution       String?           // Admin's resolution text
  resolvedBy            String?           // Admin user ID
  resolvedAt            DateTime?
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  order                 Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  client                User              @relation("DisputeClient", fields: [clientId], references: [id])
  freelancer            User              @relation("DisputeFreelancer", fields: [freelancerId], references: [id])

  @@index([orderId])
  @@index([status])
  @@index([clientId])
  @@index([freelancerId])
}

enum OrderStatus {
  PENDING_ACCEPTANCE
  IN_PROGRESS
  DELIVERED
  REVISION_REQUESTED
  COMPLETED
  CANCELLED
  DISPUTED
}

enum DeliverableType {
  FILE
  MESSAGE
  LINK
}

enum OrderEventType {
  ORDER_CREATED
  ORDER_IN_PROGRESS
  DELIVERY_SUBMITTED
  DELIVERY_ACCEPTED
  REVISION_REQUESTED
  ORDER_COMPLETED
  ORDER_CANCELLED
  DISPUTE_OPENED
  DISPUTE_RESOLVED
  STATUS_CHANGED
}

enum DisputeStatus {
  OPEN
  IN_REVIEW
  RESOLVED
  CLOSED
}

enum OfferStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}
